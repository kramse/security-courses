\documentclass[Screen16to9,17pt]{foils}
\usepackage{zencurity-slides}
\externaldocument{system-integration-exercises}
\selectlanguage{english}

% Systemintegration

\begin{document}

\mytitlepage
{9. Asynchronous and synchronous\\
 APIs, versioning, contracts}
{KEA System Integration F2020 10 ECTS}


\slide{This weeks Agenda in system integration}

\begin{list2}
\item Follow the plan:\\
\url{https://zencurity.gitbook.io/kea-it-sikkerhed/system-integration/lektionsplan}
\item Work on the hand-in assignment I: Describe the system environment for an organisation
\item Plan for April 27.\\
I will go through the subjects from the book
\item We will do a bigger exercise with APIs
\end{list2}

\slide{Goals for today}

\hlkimage{6cm}{thomas-galler-hZ3uF1-z2Qc-unsplash.jpg}

Todays goals:
\begin{list2}
\item SOA book chapters about Service API and Contract Design
\item More REST
\item Create/build and example with REST
\end{list2}

Photo by Thomas Galler on Unsplash


\slide{Time schedule}
\begin{list2}
\item 08:30 2x 45 min with 10min break\\
MessagePack, gRPC, protobuf, Apache Thrift etc.\\
SOA chapter 8: Service API and Contract Design
with Web Services
\item 10:15 2x 45 min with 10min break\\
SOA Chapter 9: Service API and Contract Design with
REST Services and Microservices\\
SOA Chapter 10: Service API and Contract Versioning
with Web Services and REST Services\\
Appendix B: REST Constraints Reference
\item 12:30 2x 45min with 10min break \\
Subject REST and exercises for the rest of the day\\
We will be a couple of larger, more advanced exercises with REST\\
Note: Flexible - so you can do them today, or later in the week if it works better with your own planning, just email me if you have problems \smiley
\item 14:15 45 min\\
Chatting, doing exercises, questions about Linux
\end{list2}


\slide{Plan for today}

\begin{list2}
\item MessagePack, gRPC, protobuf, Apache Thrift etc.
\item Asynchronous and synchronous APIs
\item versioning, contracts
\end{list2}

Exercises
\begin{list2}
\item REST related
\item
\end{list2}



\slide{MessagePack, gRPC, protobuf, Apache Thrift etc.}


\begin{list2}
\item We know JSON and XML, but there are alternatives
\item We will do a quick survey of some of the other popular methods for sending data back and forth
\item But first, how do systems send data across architectures, platforms, operating systems
\end{list2}

\slide{Serialization}

\begin{quote}

\end{quote}
In computing, {\bf serialization (or serialisation)} is the process of translating data structures or object state into a format that can be stored (for example, in a file or memory buffer) or transmitted (for example, {\bf across a network connection link) and reconstructed later (possibly in a different computer environment)}.[1] When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object. For many complex objects, such as those that make extensive use of references, this process is not straightforward. Serialization of object-oriented objects does not include any of their associated methods with which they were previously linked.
\begin{list2}
\item Java can do this with \verb+Serializable+ - for example writing objects to file and reading them again
\end{list2}

Source: {\footnotesize\\
\link{https://en.wikipedia.org/wiki/Serialization}}



\slide{Marshalling used for RPC}

\begin{quote}
In computer science, {\bf marshalling or marshaling} is the process of transforming the memory representation of an object to a data format suitable for storage or transmission, and it is typically used when data must be moved between different parts of a computer program or from one program to another. {\bf Marshalling is similar to serialization} and is used to communicate to remote objects with an object, in this case a serialized object. It simplifies complex communication, using composite objects in order to communicate instead of primitives. The inverse of marshalling is called unmarshalling (or demarshalling, similar to deserialization).
\end{quote}

\begin{list2}
  \item marshaling is about getting parameters from here to there
  \item while serialization is about copying structured data to or from a primitive form such as a byte stream
  \item serialization is one means to perform marshaling, usually implementing pass-by-value semantics.
\end{list2}

Source: {\footnotesize\\
\link{https://en.wikipedia.org/wiki/Marshalling_(computer_science)}}

\slide{TCP/IP and External Data Representation}

.
\hlkrightpic{14cm}{0cm}{compare-osi-ip.png}

\begin{quote}
External Data Representation (XDR) is a standard data serialization format, for uses such as computer network protocols. It allows data to be transferred between different kinds of computer systems. Converting from the local representation to XDR is called encoding. Converting from XDR to the local representation is called decoding.
\end{quote}

Source: {\footnotesize\\
\link{https://en.wikipedia.org/wiki/External_Data_Representation}}


\slide{MessagePack}

\begin{quote}
MessagePack is a computer data interchange format. It is a binary form for representing simple data structures like arrays and associative arrays. MessagePack aims to be as compact and simple as possible. The official implementation is available in a variety of languages such as C, C++, C\#, D, Erlang, Go, Haskell, Java, JavaScript, Lua, OCaml, Perl, PHP, Python, Ruby, Scala, Smalltalk, and Swift.[1]{\bf

Data structures processed by MessagePack loosely correspond to those used in JSON format.}
\end{quote}

\begin{list2}
\item MessagePack is more compact than JSON, but imposes limitations on array and integer sizes
\item Allows binary data and non UTF-8 encoded strings
\item MessagePack is designed for efficient transmission over the wire
\end{list2}
Source: {\footnotesize\\
\link{https://en.wikipedia.org/wiki/MessagePack}}



\slide{gRPC}

\begin{quote}
gRPC (gRPC Remote Procedure Calls[1]) is an open source remote procedure call (RPC) system initially developed at Google in 2015[2]. It uses HTTP/2 for transport, Protocol Buffers as the interface description language, and provides features such as authentication, bidirectional streaming and flow control, blocking or nonblocking bindings, and cancellation and timeouts. It generates cross-platform client and server bindings for many languages. Most common usage scenarios include connecting services in microservices style architecture and connect mobile devices, browser clients to backend services.[3]
\end{quote}

\begin{list2}
\item We will not begin running the code but tutorials are available at  \link{https://grpc.io/}
\end{list2}
Source: {\footnotesize\\
\link{https://en.wikipedia.org/wiki/GRPC} }

\slide{Protobuf used in gRPC}

\begin{quote}
Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
\end{quote}


\begin{list2}
\item Supports generated code in multiple languages:
\emph{Java, Python, Objective-C, and C++. With our new proto3 language version, you can also work with Dart, Go, Ruby, and C\#, with more languages to come.}
\end{list2}
Source: {\footnotesize\\
\link{https://developers.google.com/protocol-buffers}}

\slide{Protobuf: example definition}

\begin{minted}[fontsize=\footnotesize]{shell}
message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
\end{minted}


Source:  {\footnotesize\\\link{https://developers.google.com/protocol-buffers/docs/overview}}

\slide{Protobuf: example code C++}

\begin{minted}[fontsize=\footnotesize]{c++}
Person person;
person.set_name("John Doe");
person.set_id(1234);
person.set_email("jdoe@example.com");
fstream output("myfile", ios::out | ios::binary);
person.SerializeToOstream(&output);
\end{minted}

Then, later on, you could read your message back in:
\begin{minted}[fontsize=\footnotesize]{c++}
fstream input("myfile", ios::in | ios::binary);
Person person;
person.ParseFromIstream(&input);
cout << "Name: " << person.name() << endl;
cout << "E-mail: " << person.email() << endl;
\end{minted}


Source:  {\footnotesize\\\link{https://developers.google.com/protocol-buffers/docs/overview}}


\slide{Why protobuf?}

\begin{quote}
Protocol buffers have many advantages over XML for serializing structured data. Protocol buffers:

\begin{list2}
\item are simpler
\item are 3 to 10 times smaller
\item are 20 to 100 times faster
\item are less ambiguous
\item generate data access classes that are easier to use programmatically
\end{list2}

When this message is encoded to the protocol buffer binary format (the text format above is just a convenient human-readable representation for debugging and editing), it would probably be 28 bytes long and take around 100-200 nanoseconds to parse. The XML version is at least 69 bytes if you remove whitespace, and would take around 5,000-10,000 nanoseconds to parse.
\end{quote}
Source:  {\footnotesize\\\link{https://developers.google.com/protocol-buffers/docs/overview}}

\slide{Apache Thrift}


\begin{quote}
  The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C\#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.
...
Apache Thrift allows you to define data types and service interfaces in a simple definition file. Taking that file as input, the compiler generates code to be used to easily build RPC clients and servers that communicate seamlessly across programming languages.
\end{quote}

\begin{list2}
\item Using the input file defining the service, Thrift format
\item The compiling this generates code to be used for building clients and servers that can communicate
\item Next slides show parts of the tutorial \link{https://thrift.apache.org/tutorial/}
\end{list2}
Source: {\footnotesize\\
\link{https://thrift.apache.org/}}




\slide{Apache Thrift example input}

\begin{minted}[fontsize=\footnotesize]{shell}
/**
 * Ahh, now onto the cool part, defining a service. Services just need a name
 * and can optionally inherit from another service using the extends keyword.
 */
service Calculator extends shared.SharedService {
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   */

   void ping(),

   i32 add(1:i32 num1, 2:i32 num2),
   i32 calculate(1:i32 logid, 2:Work w) throws (1:InvalidOperation ouch),

   /**
    * This method has a oneway modifier. That means the client only makes
    * a request and does not listen for any response at all. Oneway methods
    * must be void.
\end{minted}

\slide{Apache Thrift example}

\begin{minted}[fontsize=\footnotesize]{java}
try {
  TServerTransport serverTransport = new TServerSocket(9090);
  TServer server = new TSimpleServer(new Args(serverTransport).processor(processor));
  System.out.println("Starting the simple server...");
  server.serve();
} catch (Exception e) {
  e.printStackTrace();
}
public class CalculatorHandler implements Calculator.Iface {
  private HashMap<Integer,SharedStruct> log;

  public CalculatorHandler() {
    log = new HashMap<Integer, SharedStruct>();  }

  public void ping() {
    System.out.println("ping()");  }

  public int add(int n1, int n2) {
    System.out.println("add(" + n1 + "," + n2 + ")");
    return n1 + n2;  }
  ...
\end{minted}


\slide{Apache Thrift example}

\begin{minted}[fontsize=\footnotesize]{python}
def main():
    # Make socket
    transport = TSocket.TSocket('localhost', 9090)

    # Buffering is critical. Raw sockets are very slow
    transport = TTransport.TBufferedTransport(transport)

    # Wrap in a protocol
    protocol = TBinaryProtocol.TBinaryProtocol(transport)

    # Create a client to use the protocol encoder
    client = Calculator.Client(protocol)

    # Connect!
    transport.open()

    client.ping()
    print('ping()')

    sum_ = client.add(1, 1)
\end{minted}


\slide{Lets try running the Thrift Python and Java }

\begin{list2}
\item From the tutorial \link{https://thrift.apache.org/tutorial/}
\item Run the Python client with the Python server
\item Run the Java client with the Java server
\item Then try mixing, Python client to Java server etc.
\item Note: the code is already generated, so you can get away by just running the existing programs, not doing the generation
\end{list2}


\slide{Reading Summary}

\begin{list1}
\item SOA chapter 8: Service API and Contract Design
with Web Services
\item Chapter 9: Service API and Contract Design with
REST Services and Microservices
\item Chapter 10: Service API and Contract Versioning
with Web Services and REST Services
\item and Appendix B: REST Constraints Reference
\end{list1}

Service‑Oriented Architecture: Analysis and Design for Services and Microservices, Thomas Erl, 2017
ISBN: 978-0-13-385858-7







\slide{SOA chapter 8: Service API and Contract Design\\
with Web Services}

\begin{quote}

\end{quote}

Typical considerations can include:
\begin{list2}
\item
\end{list2}
Source: {\footnotesize\\
\emph{Service‑Oriented Architecture: Analysis and Design for Services and Microservices}, Thomas Erl, 2017}

\slide{Chapter 9: Service API and Contract Design with\\
REST Services and Microservices}


\begin{quote}

\end{quote}

Typical considerations can include:
\begin{list2}
\item
\end{list2}
Source: {\footnotesize\\
\emph{Service‑Oriented Architecture: Analysis and Design for Services and Microservices}, Thomas Erl, 2017}


\slide{Chapter 10: Service API and Contract Versioning\\
with Web Services and REST Services}

\begin{quote}

\end{quote}

Typical considerations can include:
\begin{list2}
\item
\end{list2}
Source: {\footnotesize\\
\emph{Service‑Oriented Architecture: Analysis and Design for Services and Microservices}, Thomas Erl, 2017}


\slide{Appendix B: REST Constraints Reference}

\begin{quote}

\end{quote}

Typical considerations can include:
\begin{list2}
\item
\end{list2}
Source: {\footnotesize\\
\emph{Service‑Oriented Architecture: Analysis and Design for Services and Microservices}, Thomas Erl, 2017}

\slidenext

\end{document}
